<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Palettable Sprite Editor</title>
<style>
body {
    margin: 0;
    padding: 0;
    background-color: #222;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
      color: white;
}

#rendered {
  float: left;
  margin-top:150px;
  margin-left: 300px;
}

#preview {
  outline: 2px solid white;
  display: block;
  margin: 5px;
}

#raw_output{
  border:2px solid grey;
  display:block;
  margin:5px;
}

#export-wrap {
  display: block;
  margin: 0 auto;
  text-align: center;
}

#palette {
  display:block;
  position:fixed;
  float:left;
  width: 250px;
  border: 2px solid white;
  padding: 3px;
  background: #222;
  height:100%;
  overflow:scroll;
}


#canvas-controls{
  margin-left: 500px;
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>


</head>

<body translate="no" >
  <div id="palette">  
  <label for="palette0_color">Palette 0</label><input id='palette0_color' type='color'/> 
    <label for="paletteA_0">A</label><input type="radio" name="PaletteA" id="paletteA_0" value="0" checked/>
    <label for="paletteB_0">B</label><input type="radio" name="PaletteB" id="paletteB_0" value="0" />
  <br />
  <label for="palette1_color">Palette 1</label><input id='palette1_color' type='color' /> 
    <label for="paletteA_1">A</label><input type="radio" name="PaletteA" id="paletteA_1" value="1" />
    <label for="paletteB_1">B</label><input type="radio" name="PaletteB" id="paletteB_1" value="1" checked />
  <br />
  <label for="palette2_color">Palette 2</label><input id='palette2_color' type='color' /> 
    <label for="paletteA_2">A</label><input type="radio" name="PaletteA" id="paletteA_2" value="2" />
    <label for="paletteB_2">B</label><input type="radio" name="PaletteB" id="paletteB_2" value="2"  />
  <br />
  <label for="palette3_color">Palette 3</label><input id='palette3_color' type='color' /> 
    <label for="paletteA_3">A</label><input type="radio" name="PaletteA" id="paletteA_3" value="3" />
    <label for="paletteB_3">B</label><input type="radio" name="PaletteB" id="paletteB_3" value="3" />
  <br />
  <label for="palette4_color">Palette 4</label><input id='palette4_color' type='color' /> 
    <label for="paletteA_4">A</label><input type="radio" name="PaletteA" id="paletteA_4" value="4" />
    <label for="paletteB_4">B</label><input type="radio" name="PaletteB" id="paletteB_4" value="4"  />
  <br />
  <label for="palette5_color">Palette 5</label><input id='palette5_color' type='color' /> 
    <label for="paletteA_5">A</label><input type="radio" name="PaletteA" id="paletteA_5" value="5" />
    <label for="paletteB_5">B</label><input type="radio" name="PaletteB" id="paletteB_5" value="5" />
  <br />
  <label for="palette6_color">Palette 6</label><input id='palette6_color' type='color' /> 
    <label for="paletteA_6">A</label><input type="radio" name="PaletteA" id="paletteA_6" value="6" />
    <label for="paletteB_6">B</label><input type="radio" name="PaletteB" id="paletteB_6" value="6" /> 
  <br />
  <label for="palette7_color">Palette 7</label><input id='palette7_color' type='color' /> 
    <label for="paletteA_7">A</label><input type="radio" name="PaletteA" id="paletteA_7" value="7" />
    <label for="paletteB_7">B</label><input type="radio" name="PaletteB" id="paletteB_7" value="7"  />
  <br />
  
  <input type="range" min="0" max="255" value="128" class="slider" id="mixRange" />
  <input type="color" id="mixed_color_rendered" disabled="true" />
  <input type="hidden" id="mixed_color_raw" disabled="true" />
  <div> Preview: <canvas id="preview"></canvas></div>
  <div> Paletted: <canvas id="raw_output"></canvas></div>
</div>
  

 <div id="canvas-controls">
  <!--<label for="canvas_width">canvas width</label><input id="canvas_width" value="100"></input>-->
  <!--<label for="canvas_height">canvas height</label><input id="canvas_height" value="80"></input>-->
   <input type="file" id="file_to_load"></input> 
   <button id="loadRaw">Load Raw</button>
</div>

<canvas id="rendered"></canvas>

  <script src='https://www.marvinj.org/releases/marvinj-0.9.js'></script>
  
      <script id="rendered-js" >
var canvasWidthInPixels = 200,
canvasHeightInPixels = 200,
pixelWidth = 16,
pixelHeight = 16,
cursorOffset = 0.5,
cursorLineW = 2,
pixelRenderColor = "#808080",
pixelRawColor = "#002080",
drawPosRaw = [],
mark,
palettes = [
"#000000",
"#FFFFFF",
"#FF0000",
"#00FF00",
"#0000FF",
"#FFFF00",
"#00FFFF",
"#FF00FF"];


Color = function (hexOrObject) {
  var obj;
  if (hexOrObject instanceof Object) {
    obj = hexOrObject;
  } else {
    obj = LinearColorInterpolator.convertHexToRgb(hexOrObject);
  }
  this.r = parseInt(obj.r);
  this.g = parseInt(obj.g);
  this.b = parseInt(obj.b);
};
Color.prototype.asRgbCss = function () {
  return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
};

function rgbToHex(rgb) {
  var hex = Number(rgb).toString(16);
  if (hex.length < 2) {
    hex = "0" + hex;
  }
  return hex;
}

Color.prototype.asHex = function () {
  return "#" + rgbToHex(this.r) + rgbToHex(this.g) + rgbToHex(this.b);
};

Color.prototype.toRendered = function () {
  //console.log(this);
  var indexA = Math.floor(Math.min(this.r / 255.0, .99) * 8.0);
  var indexB = Math.floor(Math.min(this.g / 255.0, .99) * 8.0);
  //console.log("indexA: "+ indexA);
  //console.log("indexB: "+ indexB);
  var interp = this.b / 255.0;
  var paletteColorA = new Color(palettes[indexA]);
  var paletteColorB = new Color(palettes[indexB]);

  //console.log("Palette color A: " + paletteColorA.asHex());
  //console.log("Palette color B: " + paletteColorB.asHex());
  //console.log("lerp: " + interp);

  return LinearColorInterpolator.findColorBetween(
  paletteColorA,
  paletteColorB,
  interp * 100.0);
};

var LinearColorInterpolator = {
  // convert 6-digit hex to rgb components;
  // accepts with or without hash ("335577" or "#335577")
  convertHexToRgb: function (hex) {
    match = hex.replace(/#/, "").match(/.{1,2}/g);
    return new Color({
      r: parseInt(match[0], 16),
      g: parseInt(match[1], 16),
      b: parseInt(match[2], 16) });

  },
  // left and right are colors that you're aiming to find
  // a color between. Percentage (0-100) indicates the ratio
  // of right to left. Higher percentage means more right,
  // lower means more left.
  findColorBetween: function (left, right, percentage) {
    newColor = {};
    components = ["r", "g", "b"];
    for (var i = 0; i < components.length; i++) {
      c = components[i];
      newColor[c] = Math.round(
      left[c] + (right[c] - left[c]) * percentage / 100);

    }
    return new Color(newColor);
  } };


// ==============================================

document.addEventListener("DOMContentLoaded", function () {
  var mouse = {};
  var oldTime, delta;
  var renderCanvas = document.getElementById("rendered");
  var rawOutputCanvas = document.getElementById("raw_output");
  var previewCanvas = document.getElementById("preview");
  var renderCtx = renderCanvas.getContext("2d");
  var rawOutputCtx = rawOutputCanvas.getContext("2d");
  var previewCtx = previewCanvas.getContext("2d");

  function onPaletteChange() {
    for (const [i, value] of palettes.entries()) {
      palettes[i] = document.getElementById("palette" + i + "_color").value;
      //console.log("palette " + i + ": " + palettes[i]);
    }

    var indexA = parseInt(
    document.querySelector('input[name="PaletteA"]:checked').value);
    var indexB = parseInt(document.querySelector('input[name="PaletteB"]:checked').value);

    //console.log("Palette index A: " + indexA);
    //console.log("Palette index B: " + indexB);

    var interp = document.getElementById("mixRange").value;
    //console.log("interp: " + interp);
    //console.log("interp2: " + rgbToHex(interp));

    var rawColor = new Color({
      r: Math.floor((indexA + 0.5) / 8.0 * 255),
      g: Math.floor((indexB + 0.5) / 8.0 * 255),
      b: Math.floor(interp) });


    //console.log(rawColor);
    pixelRawColor = rawColor.asHex();

    var renderColor = rawColor.toRendered();
    pixelRenderColor = renderColor.asHex();

    document.getElementById("mixed_color_rendered").value = pixelRenderColor;
    document.getElementById("mixed_color_raw").value = pixelRawColor;

    updateRenderColors();

    //console.log("RenderColor: " + pixelRenderColor);
    //console.log("RawColor: " + pixelRawColor);
  }


  renderCanvas.width = canvasWidthInPixels * pixelHeight;
  renderCanvas.height = canvasHeightInPixels * pixelHeight;
  previewCanvas.width = renderCanvas.width / pixelWidth;
  previewCanvas.height = renderCanvas.height / pixelHeight;
  rawOutputCanvas.width = previewCanvas.width;
  rawOutputCanvas.height = previewCanvas.height;

  for (const [i, value] of palettes.entries()) {
    document.getElementById("palette" + i + "_color").value = palettes[i];
  }

  onPaletteChange();

  function drawGrid() {
    renderCtx.beginPath();
    renderCtx.strokeStyle = "rgba(150, 150, 150, 0.75)";
    var x = 0,
    y = 0;
    while (x <= renderCanvas.width) {
      renderCtx.moveTo(x, 0);
      renderCtx.lineTo(x, renderCanvas.height);
      x += pixelWidth;
    }
    while (y <= renderCanvas.height) {
      renderCtx.moveTo(0, y);
      renderCtx.lineTo(renderCanvas.width, y);
      y += pixelHeight;
    }
    renderCtx.stroke();
  }

  function updateRenderColors()
  {
    for (var p = 0; p < drawPosRaw.length; p++) {
      drawPosRaw[p].renderedColor = drawPosRaw[p].rawColorObject.toRendered().asHex();
    }
  }

  function getMousePos(event) {
    var rect = renderCanvas.getBoundingClientRect();
    return {
      x:
      Math.round((event.clientX - rect.left - pixelWidth / 2) / pixelWidth) *
      pixelWidth,
      y:
      Math.round((event.clientY - rect.top - pixelHeight / 2) / pixelHeight) *
      pixelHeight };

  }

  function clearCanvas() {
    renderCtx.clearRect(0, 0, renderCanvas.width, renderCanvas.height);
    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
    rawOutputCtx.clearRect(0, 0, rawOutputCanvas.width, rawOutputCanvas.height);
  }

  function drawImage() {
    var p = 0;
    while (p < drawPosRaw.length) {
      renderCtx.fillStyle = drawPosRaw[p].renderedColor || pixelRenderColor;
      previewCtx.fillStyle = renderCtx.fillStyle;

      rawOutputCtx.fillStyle = drawPosRaw[p].rawColor;

      renderCtx.fillRect(
      drawPosRaw[p].x,
      drawPosRaw[p].y,
      pixelWidth,
      pixelHeight);


      previewCtx.fillRect(
      drawPosRaw[p].x / pixelWidth,
      drawPosRaw[p].y / pixelHeight,
      1,
      1);


      rawOutputCtx.fillRect(
      drawPosRaw[p].x / pixelWidth,
      drawPosRaw[p].y / pixelHeight,
      1,
      1);

      p++;
    }
  }

  function drawMouse() {
    renderCtx.fillStyle = "rgba(255, 255, 255, 0.5)";
    renderCtx.fillRect(mouse.x, mouse.y, pixelWidth, cursorLineW);
    renderCtx.fillRect(mouse.x, mouse.y, cursorLineW, pixelHeight);

    renderCtx.fillStyle = pixelRenderColor;
    renderCtx.fillRect(
    mouse.x + cursorLineW,
    mouse.y + cursorLineW,
    pixelWidth * cursorOffset - 1,
    pixelHeight * cursorOffset - 1);

  }

  function render() {
    clearCanvas();
    drawGrid();
    drawImage();
    drawMouse();
    window.requestAnimationFrame(render);
  }
  window.requestAnimationFrame(render);

  var inputs = document.querySelectorAll("input[type='color']"),i;
  for (i = 0; i < inputs.length; i++) {
    if (inputs[i] !== null)
    inputs[i].addEventListener("change", onPaletteChange);
  }

  inputs = document.querySelectorAll("input[type='radio']");
  for (i = 0; i < inputs.length; i++)
  {
    if (inputs[i] !== null)
    inputs[i].addEventListener("change", onPaletteChange);
  }

  document.getElementById("mixRange").addEventListener("input", onPaletteChange);

  renderCanvas.addEventListener("mousemove", recordMouseMovement);
  renderCanvas.addEventListener("mousedown", startDrawing);
  renderCanvas.addEventListener("mouseup", stopDrawing);
  renderCanvas.addEventListener("contextmenu", clearPixel);
  document.getElementById("loadRaw").addEventListener("click", loadImage);




  function recordMouseMovement(event) {
    mouse = getMousePos(event);
  }

  function startDrawing(event) {
    if (event.button == 0) {
      mark = setInterval(function () {
        var pos = mouse;
        if (
        drawPosRaw.length > 1 &&
        drawPosRaw.slice(-1)[0].x == pos.x &&
        drawPosRaw.slice(-1)[0].y == pos.y)
        {
        } else {
          pos["rawColorObject"] = new Color(pixelRawColor);
          pos["rawColor"] = pixelRawColor;
          drawPosRaw.push(pos);
        }
      }, 10);
    }
  }

  function stopDrawing(event) {
    clearInterval(mark);
  }

  function clearPixel(event) {
    event.preventDefault();
    var savedPos = drawPosRaw.filter(function (savedPos) {
      return !(savedPos.x == mouse.x && savedPos.y == mouse.y);
    });
    drawPosRaw = savedPos;
    return false;
  }

  function loadImage()
  {
    drawPosRaw = [];
    image = new MarvinImage();
    var fileName = document.getElementById("file_to_load").files[0];
    if (fileName === undefined) return;
    var reader = new FileReader();
    reader.onload = function (event) {

      image.load(event.target.result, function () {
        var loadWidth = image.getWidth();
        var loadHeight = image.getHeight();
        console.log("loading image: (" + loadWidth + "x" + loadHeight + ")");
        for (var y = 0; y < loadHeight && y < canvasHeightInPixels; y++) {
          for (var x = 0; x < loadWidth && x < canvasWidthInPixels; x++) {
            var red = image.getIntComponent0(x, y);
            var green = image.getIntComponent1(x, y);
            var blue = image.getIntComponent2(x, y);
            var alpha = image.getAlphaComponent(x, y);

            if (alpha == 0) continue;

            var col = new Color({ r: red, g: green, b: blue });
            var pos = {
              x: x * pixelWidth,
              y: y * pixelHeight,
              rawColor: col.asHex(),
              rawColorObject: col };


            drawPosRaw.push(pos);

          }
        }
        updateRenderColors();
      });
    };
    reader.readAsDataURL(fileName);
  }
});

function exportImage() {
  var p = 0;
  while (p < drawPosRendered.length) {
    drawPosRaw[p].width = pixelWidth;
    drawPosRaw[p].height = pixelHeight;
    p++;
  }
  var resp = "var img = { layers: " + JSON.stringify(drawPosRaw) + "}";
  document.getElementById("data").innerHTML = resp;
}
    </script>

  

</body>

</html>
 

